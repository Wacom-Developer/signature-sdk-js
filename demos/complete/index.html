<!--
    Copyright (C) 2023 Wacom.
	Use of this source code is governed by the MIT License that can be found in the LICENSE file.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
	    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<!--meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"-->
	    <title>Signature SDK Demo</title>
		<link href="../common/style/wacom.css" rel="stylesheet" type="text/css">		
	    <link href="../../sigCaptDialog/style/sigCaptDialog.css" rel="stylesheet" type="text/css">		
		
		<!-- files for connection to STU tablets devices, if you don't need to connect to STU devices you don't have to include these files -->
		<script src="../common/libs/signature_sdk/stu-sdk.min.js"></script> <!-- used to connect to STU devices -->
		<script src="../../sigCaptDialog/stu_capture/aes-ecb.js"></script> <!-- utility for STU encryption -->
		<script src="../../sigCaptDialog/stu_capture/stu_capture_encryption.js"></script> <!-- STU encryption functions -->			   
	    
		<script src="../common/libs/signature_sdk/signature_sdk.js"></script> <!-- signature SDK -->
		<script src="../common/signature_sdk_helper.js"></script> <!-- signature SDK helper -->
				
        <script src="../common/browser-report.js"></script> <!-- for getting web browser information -->
				
        <script src="../../sigCaptDialog/sigCaptDialog.js"></script>
		<script src="../../sigCaptDialog/stuCaptDialog.js"></script>

		<script>	
			var mSigObj;		
            var documentHash;
			var backgroundImage;
			var sigCaptDialog
			var stuCapDialog;
			
			// This var will store the public and private keys for encryption.
			// Please note that this is only a demostration, but on a production application
			// for security reasons the private key should not be stored in a global variable.
			var encryptionKeys;

            //to remove 300 ms wait for second tap on touch screen			
			if ('addEventListener' in document) {
	            document.addEventListener('DOMContentLoaded', function() {
				    const captureBtn = document.getElementById("capture_canvas_btn");
				    captureBtn.addEventListener("touchend", function(e) {event.preventDefault(); captureBtn.click(); return false;}, false);		
	            }, false);
			}
			
			Module.onAbort = _ => {
			    alert("Web browser not supported");
 			    document.getElementById("initializeBanground").style.display = "none";
			}
		
		    Module.onRuntimeInitialized = _ => {	
                document.getElementById("version_txt").innerHTML = Module.VERSION;								
				documentHash = new Module.Hash(Module.HashType.None);
				mSigObj = new Module.SigObj();	
				
				// Here we need to set the licence. The easiest way is directly using
				// const promise = mSigObj.setLicence(key, secret);
				// however here the problem it is that we expose the key and secret publically.
				// if we want to hide the licence we can get the licence from an external server.				
				// there is a php demo file in /common/licence_proxy.php
                //const promise = mSigObj.setLicenceProxy("url from where to get the licence");
				const promise = mSigObj.setLicence("put your key licence here", "put your secret licence here");
				promise.then(value => {
				    if (value) {
					    if (navigator.hid) {				
				            document.getElementById("capture_stu_btn").disabled = false;
				        }
				
				        document.getElementById("capture_canvas_btn").disabled = false;
				        document.getElementById("document").disabled = false;				
				        document.getElementById("load_signature").disabled = false;
						document.getElementById("initializeBanground").style.display = "none";
						setDeviceName();						
					}
				});
				promise.catch(error => {
				    alert(error);
					document.getElementById("initializeBanground").style.display = "none";
				});
            }	

            function generateConfig() {
			    const config = {};
				config.strokeSize = parseInt(document.getElementById("ink_width").value);
				config.strokeColor = document.getElementById("rendering_color_box").value;
				config.width = document.getElementById("dialog_width").value;
				config.height = document.getElementById("dialog_height").value;
				config.left = document.getElementById("dialog_left").value + "px";
				config.top = document.getElementById("dialog_top").value + "px";
				config.centered = document.getElementById("is_centered").checked;
				config.title = document.getElementById("title_text").value;
				config.borderColor = document.getElementById("border_color_box").value;
				config.borderWidth = document.getElementById("border_width_box").value;
				config.hasTitle = document.getElementById("has_title_check").checked;
				
				config.signatory = {visible:document.getElementById("show_signatory_check").checked,
				                    fontFace:document.getElementById("signatory_font_type_text").value,
									fontSize:parseInt(document.getElementById("signatory_font_size_text").value),
									offsetX:parseInt(document.getElementById("signatory_offset_x_text").value),
									offsetY:parseInt(document.getElementById("signatory_offset_y_text").value),
									color:document.getElementById("signatory_color_box").value
								   };
								   
				config.reason = {visible:document.getElementById("show_reason_check").checked,
				                 fontFace:document.getElementById("reason_font_type_text").value,
								 fontSize:parseInt(document.getElementById("reason_font_size_text").value),
								 offsetX:parseInt(document.getElementById("reason_offset_x_text").value),
								 offsetY:parseInt(document.getElementById("reason_offset_y_text").value),
								 color:document.getElementById("reason_color_box").value
								};				   
								
				config.date = {visible:document.getElementById("show_date_check").checked,
				               fontFace:document.getElementById("date_font_type_text").value,
							   fontSize:parseInt(document.getElementById("date_font_size_text").value),
							   offsetX:parseInt(document.getElementById("date_offset_x_text").value),
							   offsetY:parseInt(document.getElementById("date_offset_y_text").value),
							   color:document.getElementById("date_color_box").value
							  };				   				
							  
				config.signingLine = {visible:document.getElementById("show_signing_line_check").checked,
				                      left:parseInt(document.getElementById("signing_line_left_text").value),
							          right:parseInt(document.getElementById("signing_line_right_text").value),
							          width:parseInt(document.getElementById("signing_line_width_text").value),
							          offsetY:parseInt(document.getElementById("signing_line_offset_y_text").value),
							          color:document.getElementById("signing_line_color_box").value
							  };				   							  
				
				config.buttonsFont = document.getElementById("button_font_type").value;
				config.buttons = [];				
				const fields = document.getElementById("button_list_div").getElementsByTagName("fieldset");
				for (var i=0; i<fields.length; i++) {
				    config.buttons.push({text:fields[i].elements.namedItem("button_text").value, 
					                     textColor:fields[i].elements.namedItem("button_text_color").value, 
										 backgroundColor:fields[i].elements.namedItem("button_background_color").value, 
										 borderColor:fields[i].elements.namedItem("button_border_color").value, 
										 borderWidth:parseInt(fields[i].elements.namedItem("button_border_width").value),
										 onClick:eval(fields[i].elements.namedItem("button_action").value)});
				}
				
				if (!document.getElementById("shows_as_dialog").checked) {
				    config.attachTo = "captureDiv";													    
				}							
				
				const comboSizeModes = document.getElementById("stu_fit_mode");
				config.sizeMode = comboSizeModes.options[comboSizeModes.selectedIndex].value;
				
				config.modal = document.getElementById("shows_modal").checked;
				config.draggable = document.getElementById("is_draggable").checked;
				
				const comboTools = document.getElementById("inking_tool");	
				const inkColor = document.getElementById("rendering_color_box").value;				
				const comboBackgroundMode = document.getElementById("background_image_mode");	
				config.background = {color:document.getElementById("background_color_box").value, 
				                     alpha:document.getElementById("background_opacity").value*0.01,
									 mode:comboBackgroundMode.options[comboBackgroundMode.selectedIndex].value};
									 
	            if ((document.getElementById("put_background_image").checked) && (backgroundImage)) {
				    config.background.image = backgroundImage;
				}
				
				if (document.getElementById("enable_timeout").checked) {
				    config.timeOut = {enabled:true};
					config.timeOut.time = parseInt(document.getElementById("timeOutValue").value);
					config.timeOut.onTimeOut = timeOutCallback;
				}
				
				config.minTimeOnSurface = parseInt(document.getElementById("minTimeOnSurface").value);
				
				if (!document.getElementById("allowOutSide").checked) {
				    const self = this;
				    config.onOutSide = function() {
					    alert("OutSide stroke is not allowed. Please sign again");
					    self.clear();
					    return true; // for stop capturing
					}
				}
				
				config.allowZeroPressure = document.getElementById("allowZeroPressure").checked;
				
				return config;
            }			
			
			function capture(source) {
			    if (!document.getElementById("shows_as_dialog").checked) {
				    let captureDiv = document.getElementById("captureDiv");													    
					captureDiv.style.width = document.getElementById("dialog_width").value+"px";
					captureDiv.style.height = document.getElementById("dialog_height").value+"px";
				}
			
			    document.getElementById("signatureImage").style.display = "none";
			    document.getElementById("captureDiv").style.display = "block"							 				
				
				document.getElementById("save_image_btn").disabled = true;
				document.getElementById("save_text_btn").disabled = true;
				document.getElementById("save_binary_btn").disabled = true;
				document.getElementById("save_iso_binary_btn").disabled = true;
                document.getElementById("save_iso_xml_btn").disabled = true;
				
			    if (source == "STU") {
				    captureFromSTU();
				} else {
				    captureFromCanvas();
				}
			}
			
			function captureFromCanvas() {
			    stuCapDialog = null;
			    const config = generateConfig();
				config.source = {mouse:document.getElementById("allow_mouse_check").checked,
				                 touch:document.getElementById("allow_touch_check").checked, 
						 		 pen:document.getElementById("allow_pen_check").checked}
				sigCaptDialog = new SigCaptDialog(config);
                sigCaptDialog.addEventListener("ok", function() {
				    encryptSignature();
				    renderSignature();
				});		
				
				//in this demo we use https://github.com/keithws/browser-report library for getting 
				//information about the os.
				const webBrowserData = browserReportSync();		
				const osInfo = webBrowserData.os.name + " " + webBrowserData.os.version;
                const digitizerInfo = webBrowserData.browser.name + " " + webBrowserData.browser.version;
                const nicInfo = "";
		        const where = "";
				sigCaptDialog.open(mSigObj, document.getElementById("who").value, document.getElementById("why").value, where, generateExtraData(), Module.KeyType.SHA512, documentHash, osInfo, digitizerInfo, nicInfo);
				sigCaptDialog.startCapture();
			}
			
		    async function captureFromSTU() {
			    sigCaptDialog = null;
			    const config = generateConfig();
				config.encryption = {
				    sessionId: window.crypto.getRandomValues(new Uint32Array(1))[0], // 32 bits random value
				    encryptionHandler: new MyEncryptionHandler(), // only necessary if connecting to STU-300/500/520
				    encryptionHandler2: new MyEncryptionHandler2(), // only necessary if connection to STU-430/530/540 
				};

                const stuDeviceStr = localStorage.getItem("stuDevice");
				let stuDevice;
			    if (!stuDeviceStr) {
				    const devices = await com.WacomGSS.STU.UsbDevice.requestDevices();
	                if (devices.length > 0) {
		                stuDevice = devices[0];                        					
						localStorage.setItem("stuDevice", JSON.stringify({"vendorId":stuDevice.vendorId,
						                                   "productName":stuDevice.productName,
														   "productId":stuDevice.productId}));
		                setDeviceName();
	                } else {
		                throw "No STU devices found";
	                }				
				} else {
				    stuDevice = JSON.parse(stuDeviceStr);
				    // get all the devices that we have permissions to connect
				    await navigator.hid.getDevices().then(devices => {
	                    devices.forEach(device => {							
					        if (stuDevice.vendorId === device.vendorId && stuDevice.productId === device.productId && stuDevice.productName === device.productName) {
						        stuDevice = device;
						    }
	                    });							
	                });
				}
				
				config.stuDevice = stuDevice;				
				stuCapDialog = new StuCaptDialog(config);
				stuCapDialog.addEventListener("ok", function() {
				    encryptSignature();
				    renderSignature();
				});		
				
				//in this demo we use https://github.com/keithws/browser-report library for getting 
				//information about the os.
				const webBrowserData = browserReportSync();		
				const osInfo = webBrowserData.os.name + " " + webBrowserData.os.version;
                const nicInfo = "";
		        const where = "";
				stuCapDialog.open(mSigObj, document.getElementById("who").value, document.getElementById("why").value, where, generateExtraData(), Module.KeyType.SHA512, documentHash, osInfo, nicInfo);								
			}
			
			function setDeviceName() {
			    const stuDeviceStr = localStorage.getItem("stuDevice");
				if (stuDeviceStr) {
				    document.getElementById("selectedStuDevice").innerHTML = JSON.parse(stuDeviceStr).productName;
				} else {
				    document.getElementById("selectedStuDevice").innerHTML = "None";
				}
			}
			
			function removeDevice() {
			    localStorage.removeItem("stuDevice");
				setDeviceName();
			}
			
			function clear() {
			    if (stuCapDialog) {
					stuCapDialog.clear();
				}
				
				if (sigCaptDialog) {
				    sigCaptDialog.clear();
				}
			}
			
			function cancel() {
			    if (stuCapDialog) {
					stuCapDialog.cancel();
				}
				
				if (sigCaptDialog) {
				    sigCaptDialog.cancel();
				}
			}
			
			function accept() {
			    if (stuCapDialog) {
					stuCapDialog.accept();
				}
				
				if (sigCaptDialog) {
				    if (stuCapDialog) {
					    sigCaptDialog.cancel();
					} else {
				        sigCaptDialog.accept();
					}
					
				}
			}
			
			function mmToPx(mm) {
	            var dpr = window.devicePixelRatio;
                var inch = 25.4; //1inch = 25.4 mm
                var ppi = 96;	
                return ((mm/inch)*ppi)/dpr;
            }
			
			function pxToMm(px) {
			    var dpr = window.devicePixelRatio;
                var inch = 25.4; //1inch = 25.4 mm
                var ppi = 96;	
				return ((px*dpr)/ppi)*inch;
			}
			
			function pxToInches(px) {
			    return px/96;
			}
			
			async function renderSignatureImage() {
			    // calculate the size
				let renderWidth = parseInt(document.getElementById("render_width").value);
				let renderHeight = parseInt(document.getElementById("render_height").value);
				const isRelative = document.getElementById("is_relative").checked;
				
				let renderFlags = 0x400000;
				if (isRelative) {				
				    renderFlags |= 0x2000000;
					const sx = (96/25.4)*2;
					renderWidth = Math.floor(mmToPx(mSigObj.getWidth(true)/100) + sx);
				    renderHeight = Math.floor(mmToPx(mSigObj.getHeight(true)/100) + sx);
				} else {
				    if (isNaN(renderWidth) || renderWidth <= 0) {
				        if (isNaN(renderHeight) || renderHeight <= 0) {
					        // it takes the original size							
					        renderWidth = mmToPx(mSigObj.getWidth(false)/100);
						    renderHeight = mmToPx(mSigObj.getHeight(false)/100);
						} else {
					        // it takes the size proportional to the height
						    const originalRenderWidth = mmToPx(mSigObj.getWidth()/100);
						    const originalRenderHeight = mmToPx(mSigObj.getHeight()/100);
						    renderWidth = (originalRenderWidth/originalRenderHeight)*renderHeight;
						}
					} else if (isNaN(renderHeight) || renderHeight <= 0) {
			            // it takes the size proportinal to the width
				        const originalRenderWidth = mmToPx(mSigObj.getWidth()/100);
				        const originalRenderHeight = mmToPx(mSigObj.getHeight()/100);
				        renderHeight = (originalRenderHeight/originalRenderWidth)*renderWidth;
				    }
				
				    renderWidth = Math.floor(renderWidth);
				    renderHeight = Math.floor(renderHeight);				
				    renderWidth += renderWidth % 4;
				}															
				
				const backgroundColor = document.getElementById("background_color_box").value;
				
				if (isRelative) {
				    renderWidth = -96; //dpi
					renderHeight = -96;
				}
				
				const inkColor = document.getElementById("rendering_color_box").value;
				const inkWidth = parseInt(document.getElementById("ink_width").value);
				const image = await mSigObj.renderBitmap(renderWidth, renderHeight, "image/png", inkWidth, inkColor, backgroundColor, 0, 0, renderFlags);				
				return image;				
			}
				
			async function renderSignature() {
			    const image = await renderSignatureImage();
				
				document.getElementById("captureDiv").style.display = "none"							 
	            document.getElementById("signatureImage").src = image;		
				document.getElementById("signatureImage").style.display = "block";
				
				document.getElementById("save_image_btn").disabled = false;
				document.getElementById("save_text_btn").disabled = false;
				document.getElementById("save_binary_btn").disabled = false;
                document.getElementById("save_iso_binary_btn").disabled = false;
                document.getElementById("save_iso_xml_btn").disabled = false;				
			}
			
			async function saveSignature(format) {
			    const newLink = document.createElement("a");			    
				
				if (format == "image") {
				    newLink.download = "signature.png";
					newLink.href = document.getElementById("signatureImage").src;
				} else {
				    let blob;
				    if (format == "txt") {
					    newLink.download = "signature.txt";
					    blob = new Blob([await mSigObj.getTextData(Module.TextFormat.BASE64)], { type: "text/plain" });
					} else if (format == "binary") {
					    newLink.download = "signature.fss";
					    blob = new Blob([await mSigObj.getSigData()], { type: "application/octet-stream" });
					} else if (format == "iso_binary") {
					    newLink.download = "signature.iso";
						let isoType = Module.IsoType["ISO-19794-7_BINARY"];
						if (mSigObj.canEncrypt()) {
						    if (document.getElementById("iso_encrypted_binary_radio").checked) {
							    newLink.download = "signature_encrypted.iso";
							    isoType = Module.IsoType["ISO-19794-7_ENCRYPTED_BINARY"];
							} else {
							    newLink.download = "signature_encrypted_iso.txt";
							    isoType = Module.IsoType["ISO-19794-7_ENCRYPTED_TEXT"];
							}
						}
						blob = new Blob([await mSigObj.exportIso(isoType)], { type: "application/octet-stream" });
					} else if (format == "iso_xml") {
					    newLink.download = "signature.xml";
						if (mSigObj.canEncrypt()) {
						    alert("XML ISO-19785-3 cannot be encrypted, it will be saved without encryption");
						}
						blob = new Blob([await mSigObj.exportIso(Module.IsoType["ISO-19785-3_XML"])], { type: "application/octet-stream" });
					}
					
				    if (window.webkitURL != null) {
                        newLink.href = window.webkitURL.createObjectURL(blob);
                    } else {
                        newLink.href = window.URL.createObjectURL(blob);
                        newLink.style.display = "none";
                        document.body.appendChild(newLink);
                    }
				}
				
                newLink.click(); 
		        newLink.remove();
			}
			
			async function addDocumentHash() {
			    const reader = new FileReader();
                reader.onload = async function() {                    
					try {
				        documentHash.delete();
					    const data = reader.result;   
                        const hashType = Module.HashType.SHA512;
	                    documentHash = new Module.Hash(hashType);	  
	                    var enc = new TextEncoder(); // always utf-8
	                    if (await documentHash.add(data)) {
						    alert("Document bounded properly");
	                    } else {
		                    alert("Document fails to bound");
	                    }     
	                } catch (e) {
		                alert(e);
	                }
		        }
                reader.readAsArrayBuffer(document.getElementById("document").files[0]);		
		    }
			
			function openTab(evt, tabName) {
                // Get all elements with class="tabcontent" and hide them
                var tabcontent = document.getElementsByClassName("tabcontent");
                for (var i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }

                // Get all elements with class="tablinks" and remove the class "active"
                var tablinks = document.getElementsByClassName("tablinks");
                for (var i = 0; i < tablinks.length; i++) {
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }

                // Show the current tab, and add an "active" class to the button that opened the tab
                document.getElementById(tabName).style.display = "block";
                evt.currentTarget.className += " active";
            }
			
			async function loadSignature() {
			    try {
			        //reset encryption data
					await mSigObj.setPublicKey("");
					await mSigObj.setPrivateKey("");
					await mSigObj.setEncryptionPassword("");
					await decryptSignature(mSigObj);
				} catch (e) {
				    console.log(e);
				}
			    const file = document.getElementById("load_signature").files[0];
	            if (file) {				
	                // check the type	  
	                if (("text/plain" == file.type) || ("text/xml" == file.type)) {
		                // read the file as string
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;
			                //try {
				                if ("text/plain" == file.type) {
				                    if ((!await mSigObj.setTextData(data)) || 
									    (!await readSignature(false))) {									    
				                        // maybe ISO binary text encrypted
						                try {
					                        const ad = new Module.AdditionalImportIsoData();
		                                    ad.setWho("User imported from ISO");
		                                    ad.setWhy("Signature imported from ISO");
					                        //ad.setWhen(new Date());
					                        await mSigObj.importIso(data, Module.IsoType["ISO-19794-7_ENCRYPTED_TEXT"], ad);
											readSignature(true);
						                } catch (e) {						
					                        alert(e);
						                }
				                    }
				                } else {
								    //text/xml
		                            const ad = new Module.AdditionalImportIsoData();
		                            ad.setWho("User imported from XML ISO");
		                            ad.setWhy("Signature imported from XML ISO");
									
									const domParser = new DOMParser();
									const xmlDocument = domParser.parseFromString(data, "text/xml");
									const elements = xmlDocument.getElementsByTagName("CreationDate");
									if (elements.length > 0) {
									    ad.setWhen(new Date(elements[0].innerHTML));
									}
									
					                await mSigObj.importIso(data, Module.IsoType["ISO-19785-3_XML"], ad);
					                readSignature(true);
				                }					
			                //} catch (e) {
				                //alert.log(e);
			                //}
		                }
                        reader.readAsText(file);
	                } else if (file.type == "image/png") {			  
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;
		                    var img = new Image();	     
		                    img.addEventListener('load', async function() {
                                //the image has been loaded
			                    const canvas = document.createElement("canvas");
			                    canvas.width = img.width;
			                    canvas.height = img.height;
			                    const ctx = canvas.getContext("2d");
			                    ctx.drawImage(img, 0, 0, img.width, img.height);
			                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
			                    try {
				                    await mSigObj.readEncodedBitmapBinary(imageData.data, imageData.width, imageData.height);
				                    readSignature(true);
			                    } catch (e) {
				                    alert.log(e);
			                    }			
                            }, false);
		                    img.src = data;  
                        }
                        reader.readAsDataURL(file);		
	                } else {
		                // we assume is binary data
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;            
			                try {
				                if ((!await mSigObj.setSigData(new Uint8Array(data))) ||
					                 (!await readSignature(false))) {
					                // try with iso format
					                const ad = new Module.AdditionalImportIsoData();
		                            ad.setWho("User imported from ISO");
		                            ad.setWhy("Signature imported from ISO");
					                //ad.setWhen(new Date());
					                //ad.putExtraData("extra1", "test");
					                //ad.putExtraData("extra2", "test2");				
					                if (await mSigObj.importIso(new Uint8Array(data), isEncryptedBinary(data) ? Module.IsoType['ISO-19794-7_ENCRYPTED_BINARY'] : Module.IsoType['ISO-19794-7_BINARY'], ad)) {
						                readSignature(true);
					                } else {
					                    alert("Incorrect signature data found");
										emptyLoadData();
					                }
				                }
			                } catch (e) {
				                alert(e);
								emptyLoadData();
			                }
		                }
                        reader.readAsArrayBuffer(file);		
	                }
	            }
		    }
			
			function emptyLoadData() {
			    document.getElementById("load_who").innerHTML = "";
				document.getElementById("load_why").innerHTML = "";
				document.getElementById("load_when").innerHTML = "";
				document.getElementById("load_extra_data").innerHTML = "";
				
				document.getElementById("load_digitizer_type").innerHTML = "";
				document.getElementById("load_digitizer_driver").innerHTML = "";
				document.getElementById("load_operating_system").innerHTML = "";
				document.getElementById("load_network_interface_card").innerHTML = "";
				document.getElementById("load_licence").innerHTML = "";
				
				document.getElementById("load_integrity").innerHTML = "";
				
				document.getElementById("document_load").disabled = true;				
				document.getElementById("signatureImage_loaded").style.display = "none";	
                document.getElementById("signatureimage_loaded_background").style.display = "block";				
			}
			
			async function readSignature(showError) {
				try {
				    const image = await renderSignatureImage();
				
			        document.getElementById("load_who").innerHTML = mSigObj.getWho();
				    document.getElementById("load_why").innerHTML = mSigObj.getWhy();
					let when = mSigObj.getWhen();
 					const userTimezoneOffset = when.getTimezoneOffset() * 60000;
                    when = new Date(when.getTime() + userTimezoneOffset);
					if (when.getTime() !== 0) {
				        document.getElementById("load_when").innerHTML = "The signature was captured on "+mSigObj.getWhen();
					} else {
					    document.getElementById("load_when").innerHTML = "";
					}
				    document.getElementById("load_extra_data").innerHTML = mSigObj.getExtraData("");
				
				    document.getElementById("load_digitizer_type").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer);
				    document.getElementById("load_digitizer_driver").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer_Driver);
				    document.getElementById("load_operating_system").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Machine_OS);
				    document.getElementById("load_network_interface_card").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Network_Card);
				    document.getElementById("load_licence").innerHTML = mSigObj.getLicence();				
								
				    const types = [Module.KeyType.MD5, 
				                   Module.KeyType.SHA1, 
						    	   Module.KeyType.SHA224, 
							       Module.KeyType.SHA256, 
							       Module.KeyType.SHA384, 
							       Module.KeyType.SHA512];
				
				    for (let i=0; i<types.length; i++) {
				        try {				
				            let status = await mSigObj.checkIntegrity(types[i]);
						    if (status == Module.IntegrityStatus.OK) {
						        document.getElementById("load_integrity").innerHTML = '<span style="color:green">The signature integrity is correct.</span>';
							    break;
						    } else if (status == Module.IntegrityStatus.MISSING) {
						        document.getElementById("load_integrity").innerHTML = '<span style="color:black">No Integrity data found.</span>';
							    break;
						    } else if (status != Module.IntegrityStatus.WRONG_TYPE) {
						        document.getElementById("load_integrity").innerHTML = '<span style="color:red">'+integrityStatusDesc(status)+'</span>';	
							    break;
						    }                        
				        } catch (e) {				   
				        }
                    }		

                    document.getElementById("document_load").disabled = false;		
								
				    document.getElementById("signatureImage_loaded").src = image;		
				    document.getElementById("signatureImage_loaded").style.display = "block";	
                    document.getElementById("signatureimage_loaded_background").style.display = "none";				
				} catch (e) {
				    if (showError) {
				        alert(e);
					}
					return false;
				}
				
				return true;
			}
			
			async function checkDocumentHash() {
                const reader = new FileReader();
                reader.onload = async function() {                    
					try {
					    const data = reader.result;   
						
						const types = [Module.KeyType.MD5, 
				                       Module.KeyType.SHA1, 
							           Module.KeyType.SHA224, 
							           Module.KeyType.SHA256, 
							           Module.KeyType.SHA384, 
							           Module.KeyType.SHA512];
						
						for (let i=0; i<types.length; i++) {
						    const hashType = types[i];
	                        let documentHash = new Module.Hash(hashType);	  
	                        if (await documentHash.add(data)) {
						        const status = await mSigObj.checkSignedData(documentHash);		  							
								if (status !=  Module.DataStatus.BAD_TYPE) {
								    alert(dataStatusDesc(status));
									break;
								}
	                        } else {
		                        alert("Failed to load file");
								break;
	                        }   
                            documentHash.delete();						
						}						                       
	                } catch (e) {
		                alert(e);
	                }
		        }
                reader.readAsArrayBuffer(document.getElementById("document_load").files[0]);					    
			}
			
			function loadBackgroundImage() {
			    const file = document.getElementById("background_image").files[0];
	            if (file) {
				    const reader = new FileReader();
                    reader.onload = async function() {
                        const data = reader.result;
		                backgroundImage = new Image();	     
	                    backgroundImage.src = data;  
					}
                    reader.readAsDataURL(file);										    
				}
			}
			
			function removeButton(button) {
			    document.getElementById(button).remove();
			}
			
			function addButton() {
				const newDiv = document.createElement("div");				
				const btnDiv = "btn_div_"+new Date().getTime();
				let content = '<fieldset id="'+btnDiv+'"><p>'+
				              '<label for="button_text">Button Text:</label>'+
							  '<input type="text" name="button_text"></p>'+	
							  '<p><label for="button_action">Action:</label>'+
							  '<input type="text" name="button_action"></p>'+
							  '<p><label for="button_text_color">Text color:</label>'+
							  '<input type="color" name="button_text_color" value="#000000"></p>'+
							  '<p><label for="button_background_color">Background color:</label>'+
							  '<input type="color" name="button_background_color" value="#e7e7e7"></p>'+
							  '<p><label for="button_border_with">Border width:</label>'+
							  '<input type="text" name="button_border_width" value="1"></p>'+
							  '<p><label for="button_border_color">Border color:</label>'+
							  '<input type="color" name="button_border_color" value="#cccccc"></p>'+							  
                              '<p><button onClick="removeButton(\''+btnDiv+'\')">Remove</button></p>'+									
							  '</fieldset>';
				
			    newDiv.innerHTML = content;				
				document.getElementById("button_list_div").appendChild(newDiv);				
			}
			
			function addExtraData() {
				const newDiv = document.createElement("div");				
				const extraDiv = "extra_data_div_"+new Date().getTime();
				let content = '<fieldset id="'+extraDiv+'">'+
				              '<label for="extra_name_text">Name:</label>'+
							  '<input type="text" name="extra_name">'+	
							  '<br><br><label for="extra_value">Value:</label>'+
							  '<input type="text" name="extra_value">'+
                              '<br><br>'+
                              '<button onClick="removeExtraData(\''+extraDiv+'\')">Remove</button>'+									
							  '</fieldset>';
				
			    newDiv.innerHTML = content;				
				document.getElementById("extra_data_list_div").appendChild(newDiv);				
			}
			
			function removeExtraData(extraData) {
			    document.getElementById(extraData).remove();
			}
			
			function generateExtraData() {
				const extraData = [];				
			    const list = document.getElementById("extra_data_list_div");
				const fields = list.getElementsByTagName("fieldset");
				for (var i=0; i<fields.length; i++) {
                    extraData.push({name:  fields[i].elements.namedItem("extra_name").value,
					                value: fields[i].elements.namedItem("extra_value").value
					               }
					              );								   
				}
				
				return extraData;
			}
						
			async function encryptSignature() {
			    try {
			        if (document.getElementById("no_encryption").checked) {
					    await mSigObj.setPublicKey("");
					    await mSigObj.setPrivateKey("");
				    } else {
 					    if (document.getElementById("symmetric_encryption").checked) {
				            await mSigObj.setEncryptionPassword(document.getElementById("symmetric_password").value);												
					    } else if (document.getElementById("asymmetric_encryption").checked) {
					        const pubKey = document.getElementById("public_key").value;
                            if (pubKey !== "") {								
						        await mSigObj.setPublicKey(pubKey);								
						    }
						}
						
						if (!mSigObj.canEncrypt()) {
						    alert("The signature cannot be encrypted");
						}
					}
				} catch (e) {
				    alert(e);
				}
			}	

            async function decryptSignature(signature) {
			    try {
			        if (document.getElementById("symmetric_encryption").checked) {
				        await signature.setEncryptionPassword(document.getElementById("symmetric_password").value);												
					} else if (document.getElementById("asymmetric_encryption").checked) {
					    const privKey = document.getElementById("private_key").value;
					    if (privKey !== "") {		
                            const privKeyPassword = document.getElementById("private_key_password").value;
							if (privKeyPassword !== "") {
							    // add the password to the end of the key
		                        privKey += ","+privKeyPassword;
							}
						    await signature.setPrivateKey(privKey);								
						}
				    }
				} catch (e) {
				    alert(e);
				}
            }

            function timeOutCallback(timeOnSurface) {
			    const minTimeOnSurface = parseInt(document.getElementById("minTimeOnSurface").value);
                if (minTimeOnSurface < timeOnSurface) {
				    const actionCombo = document.getElementById("dataTimeOut");
				    if (actionCombo.options[actionCombo.selectedIndex].value == "accept") {
					    accept();
					} else {
					    cancel();
					}
				} else {
				    const actionCombo = document.getElementById("emptyTimeOut");
				    if (actionCombo.options[actionCombo.selectedIndex].value == "accept") {
					    accept();
					} else {
					    cancel();
					}				
				}
			}		

		</script>
    </head>
	<body>	
	    <div id="initializeBanground" class="active" style="width:100%;height:100%;position:fixed;background:#cccccccc;">
		    <div style="position:absolute;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);">
			    <table><tr><td><div class="loader"></div></td><td>Initializing, this could take a few seconds...</td></tr></table>
			</div>
		</div>
        <div class="wrapper">    
	        <div id="header_container">
                <div id="header">
			        <a href="http://www.wacom.com/" target="_blank"><img src="../common/images/logo.png" alt="Wacom logo" class="float-left"></a>
				    <span class="float-left" style="padding-left:20px;padding-top:20px;"><h1 style="color:#ffffff">SIGNATURE SDK JS <span id="version_txt"></span> DEMO</h1></span>
			    </div>
			    <div class="tab">
                    <button id="capture_signature_tab" class="tablinks" onclick="openTab(event, 'capture_signature_div')">Capture Signature</button>
                    <button id="read_signature_tab" class="tablinks" onclick="openTab(event, 'read_signature_div')">Read Signature</button>
					<button id="settings_tab" class="tablinks" onclick="openTab(event, 'settings_div')">Settings</button>
                </div>
            </div>					
		    <div id="content_container">						
			    <div id="capture_signature_div" class="tabcontent">		        
			        <h2>Capture Signature</h2>
		            <p>
			            Wacomâ€™s Signature Library provides software components to capture handwritten signatures.<br>
			            The library simplifies the interaction with Wacom pen tablets and provides API to manage and display signatures.
			        </p>		
			        <p>
			            <label for="who">Signatory:</label><br>
				        <input type="text" id="who" name="who"><br><br>
				        <label for="why">Reason:</label><br>
				        <input type="text" id="why" name="why"><br><br>
						<p>
						    Some extra data can be included in the signature, in the form of name - value
							<fieldset style="width:400px;padding:5px;margin:5px">
							    <legend>Extra Data</legend>
								<div>
									<button onClick="addExtraData()">Add extra data</button>
								</div>
								<br>
								<div id="extra_data_list_div">
								</div>
							</fieldset>
						</p>
						
					    <p>
					        A document can be bound to the signature, in a way that later it can be checked
						    if the document has been changed or not.
					    </p>
					    <label for="document">Document:</label><br>
					    <input type="file" id="document" name="document" onchange="addDocumentHash()" disabled="disabled"><br><br>
					
			            <p>
						    Selected STU device: <span id="selectedStuDevice"></span>-<a name="removeDevice" href="#removeDevice" onClick="removeDevice()">Remove</a><br>
			                <button id="capture_stu_btn" onClick="capture('STU')" disabled="disabled">Capture signature from STU tablet</button><br><br>				    
						</p>
					    <p>
					        The input data for the signature can be taken from different sources:
					        <fieldset style="width:400px;height:40px;padding:5px;margin:5px">
		                        <legend>Input sources</legend>
							    <input type="checkbox" name="allow_mouse_check" id="allow_mouse_check" checked="checked">
		                        <label for="allow_mouse_check">Allow mouse</label>			
		                        &nbsp;&nbsp;
		                        <input type="checkbox" name="allow_touch_check" id="allow_touch_check" checked="checked">
		                        <label for="allow_touch_check">Allow touch</label>			
		                        &nbsp;&nbsp;
		                        <input type="checkbox" name="allow_pen_check" id="allow_pen_check" checked="checked">
		                        <label for="allow_pen_check">Allow pen</label>			
		                    </fieldset>
					    </p>
					    <button id="capture_canvas_btn" onClick="capture('Canvas')" disabled="disabled">Capture signature from Generic device</button>
		                <br><br>
		                <p>Signature:</p>
						<fieldset style="width:0;padding:0;margin:0;">		                    
			                <div id="captureDiv" style="width:400px;height:330px;"></div>
                            <img id="signatureImage" style="display:none">						
		                </fieldset>
					    <p>
					        <button id="save_image_btn" onClick="saveSignature('image')" disabled="disabled">Save as Image</button>&nbsp;&nbsp;
				            <button id="save_text_btn" onClick="saveSignature('txt')" disabled="disabled">Save as Text</button>&nbsp;&nbsp;
					        <button id="save_binary_btn" onClick="saveSignature('binary')" disabled="disabled">Save as Binary</button>
							<button id="save_iso_binary_btn" onClick="saveSignature('iso_binary')" disabled="disabled">Save as Binary ISO</button>
							<button id="save_iso_xml_btn" onClick="saveSignature('iso_xml')" disabled="disabled">Save as XML ISO</button>
						</p>
				    </p>
		        </div>		
			    <div id="read_signature_div" class="tabcontent">
			        <h2>Capture Signature</h2>
				    <p>
				        It is possible to get the data from a previously captured signature.
				    </p>
				    <label for="load_signature">Load signature</label><br>
				    <input type="file" name="load_signature" id="load_signature" onChange="loadSignature()" disabled="disabled"><br><br>
				    <div>
				        Signatory name: <span id="load_who" style="font-weight: bold;"></span>
				    </div>
				    <div>
				        Reason for signing: <span id="load_why" style="font-weight: bold;"></span>
				    </div>
				    <div>
				        Date and time signed: <span id="load_when" style="font-weight: bold;"></span>
				    </div>
					<div>
				        Extra data: <span id="load_extra_data" style="font-weight: bold;"></span>
				    </div>
					<div>
					    Digitizer type: <span id="load_digitizer_type" style="font-weight: bold;"></span>
					</div>
					<div>
					    Digitizer driver: <span id="load_digitizer_driver" style="font-weight: bold;"></span>
					</div>
					<div>
					    Operating System: <span id="load_operating_system" style="font-weight: bold;"></span>
					</div>
					<div>
					    Network Interface Card: <span id="load_network_interface_card" style="font-weight: bold;"></span>
					</div>
					<div>
					    Licence: <span id="load_licence" style="font-weight: bold;"></span>
					</div>
				    <br><br>
				    <div>
				        Checking the integrity of the signature we can prevent attends to modify its content.<br>
				        <span id="load_integrity" style="font-weight: bold;"></span>
				    </div>
				    <br><br>
				    <div>
				        <label for="document_load">Check bound document integrity</label><br>
					    <input type="file" id="document_load" name="document_load" onchange="checkDocumentHash()" disabled="disabled">
				    </div>
				    <br><br>
				    <div>
		                <fieldset style="width:0px;padding:5px;margin:5px">
		                    <legend>Signature Image</legend>
							<div id="signatureimage_loaded_background" style="width:400px;height:320px;"></div>
                            <img id="signatureImage_loaded" style="display:none">						
		                </fieldset>
				    </div>
			    </div>
				<div id="settings_div" class="tabcontent">
				    <h2>Settings</h2>
					<div>
		                <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Ink</legend>
							<label for="ink_width">Ink width:</label>
							<input type="number" name="ink_width" id="ink_width" value="6">
			                </br></br>
			                <label for="rendering_color_box">Ink color:</label>			
			                <input type="color" name="rendering_color_box" id="rendering_color_box" value="#0202FE">
							<br>
							<label for="background_color_box">Background color</label>			
			                <input type="color" name="background_color_box" id="background_color_box" value="#ffffff">							
							<br>
							<input type="checkbox" name="put_background_image" id="put_background_image">
							<label for="background_image">Use background image</label><br>
					        <input type="file" id="background_image" name="background_image" onChange="loadBackgroundImage()" accept="image/*">
							<br>
							<label for="background_image_mode">Background image mode</label><br>
							<select name="background_image_mode" id="background_image_mode">
			                    <option value="none">None</option>
			                    <option value="fit" selected="selected">Fit</option>
							    <option value="center">Center</option>
								<option value="pattern">Pattern</option>
		                     </select>
							<br>
							<label for="background_opacity">Background opacity</label>
							<input type="range" min="1" max="100" value="100" id="background_opacity">
							<br>
							<input type="checkbox" name="allowOutSide" id="allowOutSide" checked="checked">
							<label for="allowOutSide">Allow outside inking</label><br>
							<input type="checkbox" name="allowZeroPressure" id="allowZeroPressure" checked="checked">
							<label for="allowZeroPressure">Allow zero pressure</label><br>
		                </fieldset>
				    </div>
					<div>
					    <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Capture window</legend>                            
							<label for="dialog_width">Width:</label>
							<input type="input" name="dialog_width" id="dialog_width" value="400">
							<br>
							<label for="dialog_height">Height:</label>
							<input type="input" name="dialog_height" id="dialog_height" value="300">
							<br>
							<label for="stu_fit_mode">Size mode:</label>
		                    <select name="stu_fit_mode" id="stu_fit_mode">
			                    <option value="fixed">The values defined in Width and Height</option>
			                    <option value="fit">Fit to parent div</option>
			                    <option value="strech">Strech to parent div maintaining proportion</option>
			                    <option value="stu">STU dimensions</option>
		                    </select>
							<br>
							<input type="checkbox" name="shows_modal" id="shows_modal" checked="checked">
							<label for="shows_modal">Set as modal</label>							
							<br>
							<input type="checkbox" name="shows_as_dialog" id="shows_as_dialog">
							<label for="shows_as_dialog">Shows as dialog</label>
							<br>
							<fieldset>
							    <label for="dialog_left">Left:</label>
							    <input type="input" name="dialog_left" id="dialog_left" value="0">
							    <br>
							    <label for="dialog_top">Top:</label>
							    <input type="input" name="dialog_top" id="dialog_top" value="0">
							    <br>
								<input type="checkbox" name="is_centered" id="is_centered" checked="checked">
							    <label for="is_centered">Set as centered</label>								    
								<br>
                                <input type="checkbox" name="is_draggable" id="is_draggable" checked="checked">
							    <label for="is_draggable">Set as draggable</label>								    
								<br>
								<label for="border_color_box">Border color</label>			
			                    <input type="color" name="border_color_box" id="border_color_box" value="#0097d4">							
								<br>
								<label for="border_width_box">Border width</label>
								<input type="text" name="border_width_box" id="border_width_box" value="3">
								<br>
								<input type="checkbox" name="has_title_check" id="has_title_check" checked="checked">
							    <label for="has_title_check">Has title</label>
								<br>
								<label for="title_text">Title text</label>
								<input type="text" name="title_text" id="title_text" value="Capture signature">
							</fieldset>							
                            <p>
							    <fieldset>
								    <legend>Signatory</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_signatory_check" id="show_signatory_check" checked="checked">
							                <label for="show_signatory_check">Show signatory</label>											
										</p>
										<p>
										    <label for="signatory_font_type_text">Font type: </label>
								            <input type="text" name="signatory_font_type_text" id="signatory_font_type_text" value="Verdana">
											<br>
											<label for="signatory_font_size_text">Font size: </label>
								            <input type="text" name="signatory_font_size_text" id="signatory_font_size_text" value="20">
										</p>
										<p>
										    <label for="signatory_offset_x_text">Offset x: </label>
								            <input type="text" name="signatory_offset_x_text" id="signatory_offset_x_text" value="30">
											<br>
											<label for="signatory_offset_y_text">Offset y: </label>
								            <input type="text" name="signatory_offset_y_text" id="signatory_offset_y_text" value="5">
										</p>
										<p>
										    <label for="signatory_color_box">Text color</label>			
			                                <input type="color" name="signatory_color_box" id="signatory_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<p>
							    <fieldset>
								    <legend>Reason</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_reason_check" id="show_reason_check" checked="checked">
							                <label for="show_reason_check">Show reason</label>											
										</p>
										<p>
										    <label for="reason_font_type_text">Font type: </label>
								            <input type="text" name="reason_font_type_text" id="reason_font_type_text" value="Verdana">
											<br>
											<label for="reason_font_size_text">Font size: </label>
								            <input type="text" name="reason_font_size_text" id="reason_font_size_text" value="20">
										</p>
										<p>
										    <label for="reason_offset_x_text">Offset x: </label>
								            <input type="text" name="reason_offset_x_text" id="reason_offset_x_text" value="5">
											<br>
											<label for="reason_offset_y_text">Offset y: </label>
								            <input type="text" name="reason_offset_y_text" id="reason_offset_y_text" value="10">
										</p>
										<p>
										    <label for="reason_color_box">Text color</label>			
			                                <input type="color" name="reason_color_box" id="reason_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<p>
							    <fieldset>
								    <legend>Date</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_date_check" id="show_date_check" checked="checked">
							                <label for="show_date_check">Show date</label>											
										</p>
										<p>
										    <label for="date_font_type_text">Font type: </label>
								            <input type="text" name="date_font_type_text" id="date_font_type_text" value="Verdana">
											<br>
											<label for="date_font_size_text">Font size: </label>
								            <input type="text" name="date_font_size_text" id="date_font_size_text" value="16">
										</p>
										<p>
										    <label for="date_offset_x_text">Offset x: </label>
								            <input type="text" name="date_offset_x_text" id="date_offset_x_text" value="30">
											<br>
											<label for="date_offset_y_text">Offset y: </label>
								            <input type="text" name="date_offset_y_text" id="date_offset_y_text" value="20">
										</p>
										<p>
										    <label for="date_color_box">Text color</label>			
			                                <input type="color" name="date_color_box" id="date_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>
                            <p>
							    <fieldset>
								    <legend>Signing line</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_signing_line_check" id="show_signing_line_check" checked="checked">
							                <label for="show_signing_line_check">Show signing line</label>											
										</p>
										<p>
										    <label for="signing_line_left_text">Left: </label>
								            <input type="text" name="signing_line_left_text" id="signing_line_left_text" value="30">
											<br>
											<label for="signing_line_right_text">Right: </label>
								            <input type="text" name="signing_line_right_text" id="signing_line_right_text" value="30">
										</p>
										<p>
										    <label for="signing_line_width_text">Width: </label>
								            <input type="text" name="signing_line_width_text" id="signing_line_width_text" value="2">
											<br>
											<label for="signing_line_offset_y_text">Offset y: </label>
								            <input type="text" name="signing_line_offset_y_text" id="signing_line_offset_y_text" value="5">
										</p>
										<p>
										    <label for="signing_line_color_box">Text color</label>			
			                                <input type="color" name="signing_line_color_box" id="signing_line_color_box" value="#D3D3D3">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<fieldset>
							    <legend>Buttons</legend>
								<p>
								    <label for="button_font_type">Font type:</label>
									<input type="text" name="button_font_type" id="button_font_type" value="Arial">
								</p>
								<div>
									<button onClick="addButton()">Add Button</button>
								</div>
								<p>
								    <div id="button_list_div">
									    <fieldset id="clear_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*clear">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="clear">
                                            </p>											
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('clear_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
										<fieldset id="cancel_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*cancel">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="cancel">
                                            </p>
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('cancel_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
										<fieldset id="accept_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*ok">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="accept">
                                            </p>											
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('accept_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
								    </div>
								</p>
							</fieldset>							
		                </fieldset>
						<fieldset style="width:400px;padding:5px;margin:5px">
						    <legend>Render</legend>
							<p>
							    In order to determinate the size of the image, if none of the width and height are defined it will render
								the signature with its real size. If only one value, width or height is defined, it will render maintaining the proportion
								rescpect with the entered value. If defined both values it will render with the defined dimensions.								
							</p>
							<p>
							<label for="render_width">Width:</label>
							<input type="input" name="render_width" id="render_width" value="400"> px
							</p>
							<p>
							<label for="render_height">Height:</label>
							<input type="input" name="render_height" id="render_height" value="300"> px
							</p>
							<p>
							    If render relative both dimensions Width and Height, should be equals. In case the two of them are provided the Height will be ignored.
								<br>
								<input type="checkbox" name="is_relative" id="is_relative">
							    <label for="is_relative">Set as relative</label>								    								
							</p>
						</fieldset>
					</div>
					<div>
					    <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Encryption</legend>          
							<div>
                                <input type="radio" id="no_encryption" name="encryption_group" value="none" checked="checked">
                                <label for="no_encryption">Without Encryption</label>
                            </div>
                            <div>
                                <input type="radio" id="symmetric_encryption" name="encryption_group" value="symmetric">
                                <label for="symmetric_encryption">Symmetric encryption</label>
								<br>
								<label for"symmetric_password" style="padding-left:40px">Password: </label>
								<input type="password" id="symmetric_password">
                            </div>
                            <div>
                                <input type="radio" id="asymmetric_encryption" name="encryption_group" value="asymmetric_encryption">
                                <label for="asymmetric_encryption">Asymmetric encryption</label>
								<br>
								<label for="public_key" style="padding-left:40px">Public Key (used for encryption):</label>
								<br>
								<textarea name="public_key" id="public_key" style="margin-left:40px"></textarea>
								<br>
								<span style="padding-left:30px">Private key (used for decryption):</span>
								<br>								
								<label for="private_key_password" style="padding-left:40px">Private key password: </label>
								<input type="password" id="private_key_password">								
								<br>
								<label for="private_key" style="padding-left:40px">Private key:</label>
								<br>
								<textarea name="private_key" id="private_key" style="margin-left:40px"></textarea>
                            </div>
						</fieldset>
					</div>
					<div>
					    <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>ISO</legend>   
                            <div>
							    Save encrypted ISO-19784-7 as:<br>								
								<input type="radio" id="iso_encrypted_binary_radio" name="iso_encryption_group" value="binary" checked="checked">
                                <label for="iso_encrypted_binary_radio">As Binary</label>
								<br>
								<input type="radio" id="iso_encrypted_text_radio" name="iso_encryption_group" value="text">
                                <label for="iso_encrypted_text_radio">As Text</label>								
                            </div>							
						</fieldset>
					</div>
					<div>
					    <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Time out</legend>   
                            <div>
							    <input type="checkbox" name="enable_timeout" id="enable_timeout" checked="checked">
							    <label for="enable_timeout">Enable time out</label>								    								
								<br>
								<label for="timeOutValue">Time out value:</label>
							    <input type="input" name="timeOutValue" id="timeOutValue" value="10000">
                                <br>								
								<label for="emptyTimeOut">Action when timeout without data</label>
								<select name="emptyTimeOut" id="emptyTimeOut">
			                        <!--option name="accept">Accept</option-->
			                        <option value="cancel" selected="selected">Cancel</option>
		                        </select>
								<br>
								<label for="dataTimeOut">Action when timeout has data</label>
								<select name="dataTimeOut" id="dataTimeOut">
			                        <option value="accept" selected="selected">Accept</option>
			                        <option value="cancel">Cancel</option>
		                        </select>
                            </div>							
						</fieldset>
						<fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Capture options</legend>   
                            <div>
								<label for="minTimeOnSurface">Minimum time that is necessary to capture a signature in milliseconds:</label>
								<br>
							    <input type="input" name="minTimeOnSurface" id="minTimeOnSurface" value="300">
                            </div>							
						</fieldset>
					</div>
				</div>
		    </div>		
        </div>		
		<div id="footer_container">
            <div id="footer">
	            <a style="color:white" href="https://www.wacom.com/en-us/privacy">Wacom privacy policy</a> - 
		        <a style="color:white" href="https://www.wacom.com/en-us/cookie-notice">Wacom cookie policy</a> - Copyright Â© 2021 Wacom Company, Limited. All Rights Reserved. All other trademarks are the property of their respective owners and are used with their permission. Modifications and errors excepted.
	        </div>
        </div>        	
	</body>
	<script>
        // Get the element with id="defaultOpen" and click on it
        document.getElementById("capture_signature_tab").click();
    </script>
</html>