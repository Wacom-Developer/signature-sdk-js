<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
	    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<!--meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"-->
	    <title>Signature SDK - Complete demo</title>
		<link href="./style/wacom.css" rel="stylesheet" type="text/css">		
		<link href="/sigCaptDialog/style/sigCaptDialog.css" rel="stylesheet" type="text/css">		
	    <link href="/demos/node_modules/jquery-ui-dist/jquery-ui.min.css" rel="stylesheet" type="text/css">
	    <script src="/demos/node_modules/jquery/dist/jquery.min.js"></script>
	    <script src="/demos/node_modules/jquery-ui-dist/jquery-ui.min.js"></script>		
		<script src="/demos/node_modules/jquery-ui-touch-punch/jquery.ui.touch-punch.min.js"></script>		
		<script src="/demos/node_modules/digital-ink/node_modules/clipper-lib/clipper.js"></script>
	    <script src="/demos/node_modules/digital-ink/node_modules/js-md5/build/md5.min.js"></script>
	    <script src="/demos/node_modules/digital-ink/node_modules/poly2tri/dist/poly2tri.min.js"></script>
	    <script src="/demos/node_modules/digital-ink/node_modules/long/dist/long.js"></script>
	    <script src="/demos/node_modules/digital-ink/node_modules/protobufjs/dist/protobuf.min.js"></script>
		<script src="/demos/node_modules/digital-ink/node_modules/jszip/dist/jszip.min.js"></script>
		<script src="/demos/node_modules/digital-ink/node_modules/gl-matrix/gl-matrix-min.js"></script>
		<script src="/demos/node_modules/digital-ink/node_modules/rbush/rbush.min.js"></script>
		<script src="/demos/node_modules/digital-ink/node_modules/js-ext/js-ext-min.js"></script>
        <script src="/demos/node_modules/digital-ink/digital-ink-min.js"></script>	
	    <script type="text/javascript">
		    const {
			    fsx, Matrix,
			    InputDevice, InputListener,
			    SensorChannel, InkController,
			    Brush2D, BrushPrototype, ShapeFactory,
			    BrushGL, URIResolver,
			    Intersector, Selector,
			    PathPointContext, InkBuilder, Stroke,
			    InkModel, SpatialContext, InkCodec,
			    Color, Rect, BlendMode,
			    InkCanvas2D, StrokeRenderer2D,
			    InkCanvasGL, StrokeRendererGL,  
			    PointerData, PathProducer, PipelineStage 
		    } = DigitalInk;
	    </script>	
	    <script src="/sigCaptDialog/libs/will/InkCanvas.js"></script>
	    <script src="/sigCaptDialog/libs/will/InkCanvasRaster.js"></script>	
	    <script src="/sigCaptDialog/libs/will/ValueTransformer.js"></script>
	    <script src="/sigCaptDialog/libs/will/URIBuilder.js"></script>
	    <script src="/sigCaptDialog/libs/will/BrushPalette.js"></script>
	    <script src="/sigCaptDialog/libs/will/Config.js"></script>
	    <script src="/sigCaptDialog/libs/will/DataRepository.js"></script>
	    <script src="/sigCaptDialog/libs/will/DataModel.js"></script>
		<script src="/sigCaptDialog/libs/will/Extensions.js"></script>
		
		<script src="/demos/node_modules/stu-capture/node_modules/BigInt/src/BigInt.js"></script>		
	    <script src="/demos/node_modules/stu-capture/node_modules/sjcl/sjcl.js"></script>
		<script src="/sigCaptDialog/libs/stu_capture/stu-sdk.min.js"></script> <!-- used to connect to STU devices -->        
	    <script src="/sigCaptDialog/libs/stu_capture/stu_capture.js"></script> <!-- used for capture data from STU devices -->
	    <script src="/sigCaptDialog/libs/stu_capture/stu_capture_encryption.js"></script> <!-- STU encryption functions -->	    

        <script src="../common/libs/signature_sdk.js"></script> <!-- signature SDK -->
		<script src="../common/libs/signature_sdk_helper.js"></script> <!-- signature SDK helper -->
		
        <script src="/sigCaptDialog/sigCaptDialog.js"></script>
		<script src="/sigCaptDialog/stuCaptDialog.js"></script>
		<script>
		    const licence = "PUT HERE YOUR LICENCE STRING";
			var mSigObj;		
            var documentHash;
			var backgroundImage;
			var sigCaptDialog
			var stuCapDialog;
		
		    Module.onRuntimeInitialized = _ => {		
                document.getElementById("version_txt").innerHTML = Module.VERSION;
				if (navigator.hid) {				
				    document.getElementById("capture_stu_btn").disabled = false;
				}
				
				document.getElementById("capture_canvas_btn").disabled = false;
				document.getElementById("document").disabled = false;
				
				document.getElementById("load_signature").disabled = false;
				
				documentHash = new Module.Hash(Module.HashType.None);
				mSigObj = new Module.SigObj();	
                mSigObj.setLicence(licence);		
            }	

            function generateConfig() {
			    const config = {};
				config.width = document.getElementById("dialog_width").value;
				config.height = document.getElementById("dialog_height").value;
				config.left = document.getElementById("dialog_left").value + "px";
				config.top = document.getElementById("dialog_top").value + "px";
				config.centered = document.getElementById("is_centered").checked;
				config.title = document.getElementById("title_text").value;
				config.borderColor = document.getElementById("border_color_box").value;
				config.borderWidth = document.getElementById("border_width_box").value;
				config.hasTitle = document.getElementById("has_title_check").checked;
				
				config.signatory = {visible:document.getElementById("show_signatory_check").checked,
				                    fontFace:document.getElementById("signatory_font_type_text").value,
									fontSize:parseInt(document.getElementById("signatory_font_size_text").value),
									offsetX:parseInt(document.getElementById("signatory_offset_x_text").value),
									offsetY:parseInt(document.getElementById("signatory_offset_y_text").value),
									color:document.getElementById("signatory_color_box").value
								   };
								   
				config.reason = {visible:document.getElementById("show_reason_check").checked,
				                 fontFace:document.getElementById("reason_font_type_text").value,
								 fontSize:parseInt(document.getElementById("reason_font_size_text").value),
								 offsetX:parseInt(document.getElementById("reason_offset_x_text").value),
								 offsetY:parseInt(document.getElementById("reason_offset_y_text").value),
								 color:document.getElementById("reason_color_box").value
								};				   
								
				config.date = {visible:document.getElementById("show_date_check").checked,
				               fontFace:document.getElementById("date_font_type_text").value,
							   fontSize:parseInt(document.getElementById("date_font_size_text").value),
							   offsetX:parseInt(document.getElementById("date_offset_x_text").value),
							   offsetY:parseInt(document.getElementById("date_offset_y_text").value),
							   color:document.getElementById("date_color_box").value
							  };				   				
							  
				config.signingLine = {visible:document.getElementById("show_signing_line_check").checked,
				                      left:parseInt(document.getElementById("signing_line_left_text").value),
							          right:parseInt(document.getElementById("signing_line_right_text").value),
							          width:parseInt(document.getElementById("signing_line_width_text").value),
							          offsetY:parseInt(document.getElementById("signing_line_offset_y_text").value),
							          color:document.getElementById("signing_line_color_box").value
							  };				   							  
				
				config.buttonsFont = document.getElementById("button_font_type").value;
				config.buttons = [];				
				const fields = document.getElementById("button_list_div").getElementsByTagName("fieldset");
				for (var i=0; i<fields.length; i++) {
				    config.buttons.push({text:fields[i].elements.namedItem("button_text").value, 
					                     textColor:fields[i].elements.namedItem("button_text_color").value, 
										 backgroundColor:fields[i].elements.namedItem("button_background_color").value, 
										 borderColor:fields[i].elements.namedItem("button_border_color").value, 
										 borderWidth:parseInt(fields[i].elements.namedItem("button_border_width").value),
										 onClick:eval(fields[i].elements.namedItem("button_action").value)});
				}
				
				if (!document.getElementById("shows_as_dialog").checked) {
				    config.attachTo = "captureDiv";													    
				}							
				
				const comboSizeModes = document.getElementById("stu_fit_mode");
				config.sizeMode = comboSizeModes.options[comboSizeModes.selectedIndex].value;
				
				config.modal = document.getElementById("shows_modal").checked;
				config.draggable = document.getElementById("is_draggable").checked;
				
				const comboTools = document.getElementById("inking_tool");	
				const inkColor = document.getElementById("rendering_color_box").value;
				config.will = {tool:comboTools.options[comboTools.selectedIndex].value, color:inkColor};
				
				config.background = {color:document.getElementById("background_color_box").value, 
				                     alpha:document.getElementById("background_opacity").value*0.01};
									 
	            if ((document.getElementById("put_background_image").checked) && (backgroundImage)) {
				    config.background.image = backgroundImage;
				}
				
				return config;
            }			
			
			function capture(source) {
			    if (!document.getElementById("shows_as_dialog").checked) {
				    let captureDiv = document.getElementById("captureDiv");													    
					captureDiv.style.width = document.getElementById("dialog_width").value+"px";
					captureDiv.style.height = document.getElementById("dialog_height").value+"px";
				}
			
			    document.getElementById("signatureImage").style.display = "none";
			    document.getElementById("captureDiv").style.display = "block"							 				
				
				document.getElementById("save_image_btn").disabled = true;
				document.getElementById("save_text_btn").disabled = true;
				document.getElementById("save_binary_btn").disabled = true;
				
			    if (source == "STU") {
				    captureFromSTU();
				} else {
				    captureFromCanvas();
				}
			}
			
			function captureFromCanvas() {
			    stuCapDialog = null;
			    const config = generateConfig();
				config.source = {mouse:document.getElementById("allow_mouse_check").checked,
				                 touch:document.getElementById("allow_touch_check").checked, 
						 		 pen:document.getElementById("allow_pen_check").checked}
				sigCaptDialog = new SigCaptDialog(config);
                sigCaptDialog.addEventListener("ok", function() {
				    renderSignature();
				});		
				sigCaptDialog.open(mSigObj, document.getElementById("who").value, document.getElementById("why").value, generateExtraData(), Module.KeyType.SHA512, documentHash);
				sigCaptDialog.startCapture();
			}
			
		    function captureFromSTU() {
			    const config = generateConfig();
				stuCapDialog = new StuCaptDialog(config);
				stuCapDialog.addEventListener("ok", function() {
				    renderSignature();
				});				
				stuCapDialog.open(mSigObj, document.getElementById("who").value, document.getElementById("why").value, generateExtraData(), Module.KeyType.SHA512, documentHash);				
			}
			
			function clear() {
			    if (stuCapDialog) {
					stuCapDialog.clear();
				}
				
				if (sigCaptDialog) {
				    sigCaptDialog.clear();
				}
			}
			
			function cancel() {
			    if (stuCapDialog) {
					stuCapDialog.cancel();
				}
				
				if (sigCaptDialog) {
				    sigCaptDialog.cancel();
				}
			}
			
			function accept() {
			    if (stuCapDialog) {
					stuCapDialog.accept();
				}
				
				if (sigCaptDialog) {
				    if (stuCapDialog) {
					    sigCaptDialog.cancel();
					} else {
				        sigCaptDialog.accept();
					}
					
				}
			}
			
			function mmToPx(mm) {
	            var dpr = window.devicePixelRatio;
                var inch = 25.4; //1inch = 25.4 mm
                var ppi = 96;	
                return ((mm/inch)*ppi)/dpr;
            }
			
			function pxToMm(px) {
			    var dpr = window.devicePixelRatio;
                var inch = 25.4; //1inch = 25.4 mm
                var ppi = 96;	
				return ((px*dpr)/ppi)*inch;
			}
			
			function pxToInches(px) {
			    return px/96;
			}
			
			async function renderSignatureImage() {
			    // calculate the size
				let renderWidth = parseInt(document.getElementById("render_width").value);
				let renderHeight = parseInt(document.getElementById("render_height").value);
				const isRelative = document.getElementById("is_relative").checked;
				const useWILL = true;//document.getElementById("use_will").checked;
				
				let renderFlags = 0x400000;
				if (isRelative) {				
				    renderFlags |= 0x2000000;
					const sx = (96/25.4)*2;
					renderWidth = Math.floor(mmToPx(mSigObj.getWidth(true)/100) + sx);
				    renderHeight = Math.floor(mmToPx(mSigObj.getHeight(true)/100) + sx);
				} else {
				    if (isNaN(renderWidth) || renderWidth <= 0) {
				        if (isNaN(renderHeight) || renderHeight <= 0) {
					        // it takes the original size							
					        renderWidth = mmToPx(mSigObj.getWidth(false)/100);
						    renderHeight = mmToPx(mSigObj.getHeight(false)/100);
						} else {
					        // it takes the size proportional to the height
						    const originalRenderWidth = mmToPx(mSigObj.getWidth()/100);
						    const originalRenderHeight = mmToPx(mSigObj.getHeight()/100);
						    renderWidth = (originalRenderWidth/originalRenderHeight)*renderHeight;
						}
					} else if (isNaN(renderHeight) || renderHeight <= 0) {
			            // it takes the size proportinal to the width
				        const originalRenderWidth = mmToPx(mSigObj.getWidth()/100);
				        const originalRenderHeight = mmToPx(mSigObj.getHeight()/100);
				        renderHeight = (originalRenderHeight/originalRenderWidth)*renderWidth;
				    }
				
				    renderWidth = Math.floor(renderWidth);
				    renderHeight = Math.floor(renderHeight);				
				    renderWidth += renderWidth % 4;
				}															
				
				const backgroundColor = document.getElementById("background_color_box").value;
				
				if (isRelative) {
				    renderWidth = -96; //dpi
					renderHeight = -96;
				}
				
				const inkColor = document.getElementById("rendering_color_box").value;
				const image = await new Promise(function(resolve, reject) {
				    mSigObj.renderBitmap(renderWidth, renderHeight, "image/png", 3.0, inkColor, backgroundColor, 0, 0, renderFlags,
					    resolve,
						reject,
				        async function(width, height) {
						    if (useWILL) {
					            const canvas = new OffscreenCanvas(width, height);
				                const inkCanvas = await new InkCanvasRaster(canvas, canvas.width, canvas.height);
	                            await BrushPalette.configure(inkCanvas.canvas.ctx);

		                        window.WILL = inkCanvas;
	                            WILL.type = "raster";
								WILL.setColor(Color.fromHex(inkColor));
	                            const comboTools = document.getElementById("inking_tool");	
								const toolName = comboTools.options[comboTools.selectedIndex].value;
	                            await WILL.setTool(toolName);							
						        return inkCanvas;
							} else {
							    return null;
							}
					   }
				    );
				});
				
				if (window.WILL) {
		            await BrushPalette.delete();
	                await window.WILL.delete();		
		            window.WILL = null;
	            }
				
				return image;
			}
				
			async function renderSignature() {
			    const image = await renderSignatureImage();
				
				document.getElementById("captureDiv").style.display = "none"							 
	            document.getElementById("signatureImage").src = image;		
				document.getElementById("signatureImage").style.display = "block";
				
				document.getElementById("save_image_btn").disabled = false;
				document.getElementById("save_text_btn").disabled = false;
				document.getElementById("save_binary_btn").disabled = false;							
			}
			
			async function saveSignature(format) {
			    const newLink = document.createElement("a");			    
				
				if (format == "image") {
				    newLink.download = "signature.png";
					newLink.href = document.getElementById("signatureImage").src;
				} else {
				    let blob;
				    if (format == "txt") {
					    newLink.download = "signature.txt";
					    blob = new Blob([await mSigObj.getTextData(Module.TextFormat.BASE64)], { type: "text/plain" });
					} else if (format == "binary") {
					    newLink.download = "signature.fss";
					    blob = new Blob([await mSigObj.getSigData()], { type: "application/octet-stream" });
					}
					
				    if (window.webkitURL != null) {
                        newLink.href = window.webkitURL.createObjectURL(blob);
                    } else {
                        newLink.href = window.URL.createObjectURL(blob);
                        newLink.style.display = "none";
                        document.body.appendChild(newLink);
                    }
				}
				
                newLink.click(); 
		        newLink.remove();
			}
			
			async function addDocumentHash() {
			    const reader = new FileReader();
                reader.onload = async function() {                    
					try {
				        documentHash.delete();
					    const data = reader.result;   
                        const hashType = Module.HashType.SHA512;
	                    documentHash = new Module.Hash(hashType);	  
	                    var enc = new TextEncoder(); // always utf-8
	                    if (await documentHash.add(data)) {
						    alert("Document bounded properly");
	                    } else {
		                    alert("Document fails to bound");
	                    }     
	                } catch (e) {
		                alert(e);
	                }
		        }
                reader.readAsArrayBuffer(document.getElementById("document").files[0]);		
		    }
			
			function openTab(evt, tabName) {
                // Get all elements with class="tabcontent" and hide them
                var tabcontent = document.getElementsByClassName("tabcontent");
                for (var i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }

                // Get all elements with class="tablinks" and remove the class "active"
                var tablinks = document.getElementsByClassName("tablinks");
                for (var i = 0; i < tablinks.length; i++) {
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }

                // Show the current tab, and add an "active" class to the button that opened the tab
                document.getElementById(tabName).style.display = "block";
                evt.currentTarget.className += " active";
            }
			
			async function loadSignature() {
			    const file = document.getElementById("load_signature").files[0];
	            if (file) {
	                // check the type	  
	                if (("text/plain" == file.type) || ("text/xml" == file.type)) {
		                // read the file as string
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;
			                try {
				                if ("text/plain" == file.type) {
				                    if (await mSigObj.setTextData(data)) {
					                    readSignature();
				                    } else {
						                // maybe ISO binary text encrypted
						                try {
					                        const ad = new Module.AdditionalImportIsoData();
		                                    ad.setWho("User imported from ISO");
		                                    ad.setWhy("Signature imported from ISO");
					                        ad.setWhen(new Date());
					                        await mSigObj.importIso(data, Module.IsoType.ISO19784_7_ENCRYPTED_TEXT, ad);
											readSignature();
						                } catch (e) {						
					                        log("Incorrect signature data found");
						                }
				                    }
				                } else {
		                            const ad = new Module.AdditionalImportIsoData();
		                            ad.setWho("User imported from XML ISO");
		                            ad.setWhy("Signature imported from XML ISO");
					                ad.setWhen(new Date());
					                await mSigObj.importIso(data, Module.IsoType.ISO19785_3_XML, ad);
					                readSignature();
				                }					
			                } catch (e) {
				                console.log("Error loading signature as text "+e);
			                }
		                }
                        reader.readAsText(file);
	                } else if ((file.type == "image/png") || (file.type == "image/jpeg")) {			  
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;
		                    var img = new Image();	     
		                    img.addEventListener('load', async function() {
                                //the image has been loaded
			                    const canvas = document.createElement("canvas");
			                    canvas.width = img.width;
			                    canvas.height = img.height;
			                    const ctx = canvas.getContext("2d");
			                    ctx.drawImage(img, 0, 0, img.width, img.height);
			                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
			                    try {
				                    await mSigObj.readEncodedBitmapBinary(imageData.data, imageData.width, imageData.height);
				                    readSignature();
			                    } catch (e) {
				                    console.log("Error loading image "+e);
			                    }			
                            }, false);
		                    img.src = data;  
                        }
                        reader.readAsDataURL(file);		
	                } else {
		                // we assume is binary data
		                const reader = new FileReader();
                        reader.onload = async function() {
                            const data = reader.result;            
			                try {
				                if (await mSigObj.setSigData(new Uint8Array(data))) {
					                readSignature();
				                } else {
					                // try with iso format
					                const ad = new Module.AdditionalImportIsoData();
		                            ad.setWho("User imported from ISO");
		                            ad.setWhy("Signature imported from ISO");
					                ad.setWhen(new Date());
					                //ad.putExtraData("extra1", "test");
					                //ad.putExtraData("extra2", "test2");				
					                if (await mSigObj.importIso(new Uint8Array(data), isEncryptedBinary(data) ? Module.IsoType.ISO19784_7_ENCRYPTED_BINARY : Module.IsoType.ISO19784_7_BINARY, ad)) {
						                readSignature();
					                } else {
					                    console.log("Incorrect signature data found");
										emptyLoadData();
					                }
				                }
			                } catch (e) {
				                console.log("Error loading signature as binary "+e);
								emptyLoadData();
			                }
		                }
                        reader.readAsArrayBuffer(file);		
	                }
	            }
		    }
			
			function emptyLoadData() {
			    document.getElementById("load_who").innerHTML = "";
				document.getElementById("load_why").innerHTML = "";
				document.getElementById("load_when").innerHTML = "";
				document.getElementById("load_extra_data").innerHTML = "";
				
				document.getElementById("load_digitizer_type").innerHTML = "";
				document.getElementById("load_digitizer_driver").innerHTML = "";
				document.getElementById("load_operating_system").innerHTML = "";
				document.getElementById("load_network_interface_card").innerHTML = "";
				document.getElementById("load_licence").innerHTML = "";
				
				document.getElementById("load_integrity").innerHTML = "";
				
				document.getElementById("document_load").disabled = true;				
				document.getElementById("signatureImage_loaded").style.display = "none";	
                document.getElementById("signatureimage_loaded_background").style.display = "block";				
			}
			
			async function readSignature() {
			    document.getElementById("load_who").innerHTML = mSigObj.getWho();
				document.getElementById("load_why").innerHTML = mSigObj.getWhy();
				let date = mSigObj.getWhen();
				document.getElementById("load_when").innerHTML = "The signature was captured on "+date;
				document.getElementById("load_extra_data").innerHTML = mSigObj.getExtraData("");
				
				document.getElementById("load_digitizer_type").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer);
				document.getElementById("load_digitizer_driver").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Digitizer_Driver);
				document.getElementById("load_operating_system").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Machine_OS);
				document.getElementById("load_network_interface_card").innerHTML = mSigObj.getAdditionalData(Module.CaptureData.Network_Card);
				document.getElementById("load_licence").innerHTML = mSigObj.getLicence();				
								
				const types = [Module.KeyType.MD5, 
				               Module.KeyType.SHA1, 
							   Module.KeyType.SHA224, 
							   Module.KeyType.SHA256, 
							   Module.KeyType.SHA384, 
							   Module.KeyType.SHA512];
				
				for (let i=0; i<types.length; i++) {
				    try {				
				        let status = await mSigObj.checkIntegrity(types[i]);
						if (status == Module.IntegrityStatus.OK) {
						    document.getElementById("load_integrity").innerHTML = '<span style="color:green">The signature integrity is correct.</span>';
							break;
						} else if (status == Module.IntegrityStatus.MISSING) {
						    document.getElementById("load_integrity").innerHTML = '<span style="color:black">No Integrity data found.</span>';
							break;
						} else if (status != Module.IntegrityStatus.WRONG_TYPE) {
						    document.getElementById("load_integrity").innerHTML = '<span style="color:red">'+integrityStatusDesc(status)+'</span>';	
							break;
						}                        
				    } catch (e) {				   
				    }
                }		

                document.getElementById("document_load").disabled = false;				
				const image = await renderSignatureImage();
				
				document.getElementById("signatureImage_loaded").src = image;		
				document.getElementById("signatureImage_loaded").style.display = "block";	
                document.getElementById("signatureimage_loaded_background").style.display = "none";				
			}
			
			async function checkDocumentHash() {
                const reader = new FileReader();
                reader.onload = async function() {                    
					try {
					    const data = reader.result;   
						
						const types = [Module.KeyType.MD5, 
				                       Module.KeyType.SHA1, 
							           Module.KeyType.SHA224, 
							           Module.KeyType.SHA256, 
							           Module.KeyType.SHA384, 
							           Module.KeyType.SHA512];
						
						for (let i=0; i<types.length; i++) {
						    const hashType = types[i];
	                        let documentHash = new Module.Hash(hashType);	  
	                        if (await documentHash.add(data)) {
						        const status = await mSigObj.checkSignedData(documentHash);		  							
								if (status !=  Module.DataStatus.BAD_TYPE) {
								    alert(dataStatusDesc(status));
									break;
								}
	                        } else {
		                        alert("Failed to load file");
								break;
	                        }   
                            documentHash.delete();						
						}						                       
	                } catch (e) {
		                alert(e);
	                }
		        }
                reader.readAsArrayBuffer(document.getElementById("document_load").files[0]);					    
			}
			
			function loadBackgroundImage() {
			    const file = document.getElementById("background_image").files[0];
	            if (file) {
				    const reader = new FileReader();
                    reader.onload = async function() {
                        const data = reader.result;
		                backgroundImage = new Image();	     
	                    backgroundImage.src = data;  
					}
                    reader.readAsDataURL(file);										    
				}
			}
			
			function removeButton(button) {
			    document.getElementById(button).remove();
			}
			
			function addButton() {
				const newDiv = document.createElement("div");				
				const btnDiv = "btn_div_"+new Date().getTime();
				let content = '<fieldset id="'+btnDiv+'"><p>'+
				              '<label for="button_text">Button Text:</label>'+
							  '<input type="text" name="button_text"></p>'+	
							  '<p><label for="button_action">Action:</label>'+
							  '<input type="text" name="button_action"></p>'+
							  '<p><label for="button_text_color">Text color:</label>'+
							  '<input type="color" name="button_text_color" value="#000000"></p>'+
							  '<p><label for="button_background_color">Background color:</label>'+
							  '<input type="color" name="button_background_color" value="#e7e7e7"></p>'+
							  '<p><label for="button_border_with">Border width:</label>'+
							  '<input type="text" name="button_border_width" value="1"></p>'+
							  '<p><label for="button_border_color">Border color:</label>'+
							  '<input type="color" name="button_border_color" value="#cccccc"></p>'+							  
                              '<p><button onClick="removeButton(\''+btnDiv+'\')">Remove</button></p>'+									
							  '</fieldset>';
				
			    newDiv.innerHTML = content;				
				document.getElementById("button_list_div").appendChild(newDiv);				
			}
			
			function addExtraData() {
				const newDiv = document.createElement("div");				
				const extraDiv = "extra_data_div_"+new Date().getTime();
				let content = '<fieldset id="'+extraDiv+'">'+
				              '<label for="extra_name_text">Name:</label>'+
							  '<input type="text" name="extra_name">'+	
							  '<br><br><label for="extra_value">Value:</label>'+
							  '<input type="text" name="extra_value">'+
                              '<br><br>'+
                              '<button onClick="removeExtraData(\''+extraDiv+'\')">Remove</button>'+									
							  '</fieldset>';
				
			    newDiv.innerHTML = content;				
				document.getElementById("extra_data_list_div").appendChild(newDiv);				
			}
			
			function removeExtraData(extraData) {
			    document.getElementById(extraData).remove();
			}
			
			function generateExtraData() {
				const extraData = [];				
			    const list = document.getElementById("extra_data_list_div");
				const fields = list.getElementsByTagName("fieldset");
				for (var i=0; i<fields.length; i++) {
                    extraData.push({name:  fields[i].elements.namedItem("extra_name").value,
					                value: fields[i].elements.namedItem("extra_value").value
					               }
					              );								   
				}
				
				return extraData;
			}
			
		</script>
    </head>
	<body>	
        <div class="wrapper">    
	        <div id="header_container">
                <div id="header">
			        <a href="http://www.wacom.com/" target="_blank"><img src="./images/logo.png" alt="Wacom logo" class="float-left"></a>
				    <span class="float-left" style="padding-left:20px;padding-top:20px;"><h1 style="color:#ffffff">SIGNATURE SDK JS <span id="version_txt"></span> DEMO</h1></span>
			    </div>
			    <div class="tab">
                    <button id="capture_signature_tab" class="tablinks" onclick="openTab(event, 'capture_signature_div')">Capture Signature</button>
                    <button id="read_signature_tab" class="tablinks" onclick="openTab(event, 'read_signature_div')">Read Signature</button>
					<button id="settings_tab" class="tablinks" onclick="openTab(event, 'settings_div')">Settings</button>
                </div>
            </div>					
		    <div id="content_container">						
			    <div id="capture_signature_div" class="tabcontent">		        
			        <h2>Capture Signature</h2>
		            <p>
			            Wacom’s Signature Library provides software components to capture handwritten signatures.<br>
			            The library simplifies the interaction with Wacom pen tablets and provides API to manage and display signatures.
			        </p>		
			        <p>
			            <label for="who">Signatory:</label><br>
				        <input type="text" id="who" name="who"><br><br>
				        <label for="why">Reason:</label><br>
				        <input type="text" id="why" name="why"><br><br>
						<p>
						    Some extra data can be included in the signature, in the form of name - value
							<fieldset style="width:400px;padding:5px;margin:5px">
							    <legend>Extra Data</legend>
								<div>
									<button onClick="addExtraData()">Add extra data</button>
								</div>
								<br>
								<div id="extra_data_list_div">
								</div>
							</fieldset>
						</p>
						
					    <p>
					        A document can be bound to the signature, in a way that later it can be checked
						    if the document has been changed or not.
					    </p>
					    <label for="document">Document:</label><br>
					    <input type="file" id="document" name="document" onchange="addDocumentHash()" disabled="disabled"><br><br>
					
			            <button id="capture_stu_btn" onClick="capture('STU')" disabled="disabled">Capture signature from STU tablet</button><br><br>				    
					    <p>
					        The input data for the signature can be taken from different sources:
					        <fieldset style="width:400px;height:40px;padding:5px;margin:5px">
		                        <legend>Input sources</legend>
							    <input type="checkbox" name="allow_mouse_check" id="allow_mouse_check" checked="checked">
		                        <label for="allow_mouse_check">Allow mouse</label>			
		                        &nbsp;&nbsp;
		                        <input type="checkbox" name="allow_touch_check" id="allow_touch_check" checked="checked">
		                        <label for="allow_touch_check">Allow touch</label>			
		                        &nbsp;&nbsp;
		                        <input type="checkbox" name="allow_pen_check" id="allow_pen_check" checked="checked">
		                        <label for="allow_pen_check">Allow pen</label>			
		                    </fieldset>
					    </p>
					    <button id="capture_canvas_btn" onClick="capture('Canvas')">Capture signature from Generic device</button>
		                <br><br>
		                <fieldset style="width:0;padding:5px;margin:5px;">
		                    <legend>Signature</legend>
			                <div id="captureDiv" style="width:400px;height:330px;"></div>
                            <img id="signatureImage" style="display:none">						
		                </fieldset>
					    <br><br>
					    <button id="save_image_btn" onClick="saveSignature('image')" disabled="disabled">Save as Image</button>&nbsp;&nbsp;
				        <button id="save_text_btn" onClick="saveSignature('txt')" disabled="disabled">Save as Text</button>&nbsp;&nbsp;
					    <button id="save_binary_btn" onClick="saveSignature('binary')" disabled="disabled">Save as Binary</button>
				    </p>
		        </div>		
			    <div id="read_signature_div" class="tabcontent">
			        <h2>Capture Signature</h2>
				    <p>
				        It is possible to get the data from a previously captured signature.
				    </p>
				    <label for="load_signature">Load signature</label><br>
				    <input type="file" name="load_signature" id="load_signature" onChange="loadSignature()" disabled="disabled"><br><br>
				    <div>
				        Signatory name: <span id="load_who" style="font-weight: bold;"></span>
				    </div>
				    <div>
				        Reason for signing: <span id="load_why" style="font-weight: bold;"></span>
				    </div>
				    <div>
				        Date and time signed: <span id="load_when" style="font-weight: bold;"></span>
				    </div>
					<div>
				        Extra data: <span id="load_extra_data" style="font-weight: bold;"></span>
				    </div>
					<div>
					    Digitizer type: <span id="load_digitizer_type" style="font-weight: bold;"></span>
					</div>
					<div>
					    Digitizer driver: <span id="load_digitizer_driver" style="font-weight: bold;"></span>
					</div>
					<div>
					    Operating System: <span id="load_operating_system" style="font-weight: bold;"></span>
					</div>
					<div>
					    Network Interface Card: <span id="load_network_interface_card" style="font-weight: bold;"></span>
					</div>
					<div>
					    Licence: <span id="load_licence" style="font-weight: bold;"></span>
					</div>
				    <br><br>
				    <div>
				        Checking the integrity of the signature we can prevent attends to modify its content.<br>
				        <span id="load_integrity" style="font-weight: bold;"></span>
				    </div>
				    <br><br>
				    <div>
				        <label for="document_load">Check bound document integrity</label><br>
					    <input type="file" id="document_load" name="document_load" onchange="checkDocumentHash()" disabled="disabled">
				    </div>
				    <br><br>
				    <div>
		                <fieldset style="width:0px;padding:5px;margin:5px">
		                    <legend>Signature Image</legend>
							<div id="signatureimage_loaded_background" style="width:400px;height:320px;"></div>
                            <img id="signatureImage_loaded" style="display:none">						
		                </fieldset>
				    </div>
			    </div>
				<div id="settings_div" class="tabcontent">
				    <h2>Settings</h2>
					<div>
		                <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Ink</legend>
							<!--input type="checkbox" name="use_will" id="use_will" checked="checked">
							<label for="use_will">use WILL</label-->							
							<br>
                            <label for="inking_tool">Inking tool:</label>
		                    <select name="inking_tool" id="inking_tool">
			                    <option name="pen">pen</option>
			                    <option name="felt">felt</option>
			                    <option name="brush">brush</option>
			                    <option name="marker">marker</option>
		                        <option name="pencil">pencil</option>
	                            <option name="waterBrush">waterBrush</option>
	                            <option name="inkBrush">inkBrush</option>
	                            <option name="rainbowBrush">rainbowBrush</option>
	                            <option name="crayon">crayon</option>
		                    </select>
			                </br></br>
			                <label for="rendering_color_box">Ink color:</label>			
			                <input type="color" name="rendering_color_box" id="rendering_color_box" value="#000F55">
							<br>
							<label for="background_color_box">Background color</label>			
			                <input type="color" name="background_color_box" id="background_color_box" value="#ffffff">							
							<br>
							<input type="checkbox" name="put_background_image" id="put_background_image">
							<label for="background_image">Use background image</label><br>
					        <input type="file" id="background_image" name="background_image" onChange="loadBackgroundImage()" accept="image/*">
							<br>
							<label for="background_opacity">Background opacity</label>
							<input type="range" min="1" max="100" value="100" id="background_opacity">
		                </fieldset>
				    </div>
					<div>
					    <fieldset style="width:400px;padding:5px;margin:5px">
		                    <legend>Capture window</legend>                            
							<label for="dialog_width">Width:</label>
							<input type="input" name="dialog_width" id="dialog_width" value="400">
							<br>
							<label for="dialog_height">Height:</label>
							<input type="input" name="dialog_height" id="dialog_height" value="300">
							<br>
							<label for="stu_fit_mode">Size mode:</label>
		                    <select name="stu_fit_mode" id="stu_fit_mode">
			                    <option value="fixed">The values defined in Width and Height</option>
			                    <option value="fit">Fit to parent div</option>
			                    <option value="strech">Strech to parent div maintaining proportion</option>
			                    <option value="stu">STU dimensions</option>
		                    </select>
							<br>
							<input type="checkbox" name="shows_modal" id="shows_modal" checked="checked">
							<label for="shows_modal">Set as modal</label>							
							<br>
							<input type="checkbox" name="shows_as_dialog" id="shows_as_dialog">
							<label for="shows_as_dialog">Shows as dialog</label>
							<br>
							<fieldset>
							    <label for="dialog_left">Left:</label>
							    <input type="input" name="dialog_left" id="dialog_left" value="0">
							    <br>
							    <label for="dialog_top">Top:</label>
							    <input type="input" name="dialog_top" id="dialog_top" value="0">
							    <br>
								<input type="checkbox" name="is_centered" id="is_centered" checked="checked">
							    <label for="is_centered">Set as centered</label>								    
								<br>
                                <input type="checkbox" name="is_draggable" id="is_draggable" checked="checked">
							    <label for="is_draggable">Set as draggable</label>								    
								<br>
								<label for="border_color_box">Border color</label>			
			                    <input type="color" name="border_color_box" id="border_color_box" value="#0097d4">							
								<br>
								<label for="border_width_box">Border width</label>
								<input type="text" name="border_width_box" id="border_width_box" value="3">
								<br>
								<input type="checkbox" name="has_title_check" id="has_title_check" checked="checked">
							    <label for="has_title_check">Has title</label>
								<br>
								<label for="title_text">Title text</label>
								<input type="text" name="title_text" id="title_text" value="Capture signature">
							</fieldset>							
                            <p>
							    <fieldset>
								    <legend>Signatory</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_signatory_check" id="show_signatory_check" checked="checked">
							                <label for="show_signatory_check">Show signatory</label>											
										</p>
										<p>
										    <label for="signatory_font_type_text">Font type: </label>
								            <input type="text" name="signatory_font_type_text" id="signatory_font_type_text" value="Verdana">
											<br>
											<label for="signatory_font_size_text">Font size: </label>
								            <input type="text" name="signatory_font_size_text" id="signatory_font_size_text" value="20">
										</p>
										<p>
										    <label for="signatory_offset_x_text">Offset x: </label>
								            <input type="text" name="signatory_offset_x_text" id="signatory_offset_x_text" value="30">
											<br>
											<label for="signatory_offset_y_text">Offset y: </label>
								            <input type="text" name="signatory_offset_y_text" id="signatory_offset_y_text" value="5">
										</p>
										<p>
										    <label for="signatory_color_box">Text color</label>			
			                                <input type="color" name="signatory_color_box" id="signatory_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<p>
							    <fieldset>
								    <legend>Reason</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_reason_check" id="show_reason_check" checked="checked">
							                <label for="show_reason_check">Show reason</label>											
										</p>
										<p>
										    <label for="reason_font_type_text">Font type: </label>
								            <input type="text" name="reason_font_type_text" id="reason_font_type_text" value="Verdana">
											<br>
											<label for="reason_font_size_text">Font size: </label>
								            <input type="text" name="reason_font_size_text" id="reason_font_size_text" value="20">
										</p>
										<p>
										    <label for="reason_offset_x_text">Offset x: </label>
								            <input type="text" name="reason_offset_x_text" id="reason_offset_x_text" value="5">
											<br>
											<label for="reason_offset_y_text">Offset y: </label>
								            <input type="text" name="reason_offset_y_text" id="reason_offset_y_text" value="10">
										</p>
										<p>
										    <label for="reason_color_box">Text color</label>			
			                                <input type="color" name="reason_color_box" id="reason_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<p>
							    <fieldset>
								    <legend>Date</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_date_check" id="show_date_check" checked="checked">
							                <label for="show_date_check">Show date</label>											
										</p>
										<p>
										    <label for="date_font_type_text">Font type: </label>
								            <input type="text" name="date_font_type_text" id="date_font_type_text" value="Verdana">
											<br>
											<label for="date_font_size_text">Font size: </label>
								            <input type="text" name="date_font_size_text" id="date_font_size_text" value="16">
										</p>
										<p>
										    <label for="date_offset_x_text">Offset x: </label>
								            <input type="text" name="date_offset_x_text" id="date_offset_x_text" value="30">
											<br>
											<label for="date_offset_y_text">Offset y: </label>
								            <input type="text" name="date_offset_y_text" id="date_offset_y_text" value="20">
										</p>
										<p>
										    <label for="date_color_box">Text color</label>			
			                                <input type="color" name="date_color_box" id="date_color_box" value="#000000">							
										</p>
									</div>
								</fieldset>
                            </p>
                            <p>
							    <fieldset>
								    <legend>Signing line</legend>
									<div>
									    <p>
									        <input type="checkbox" name="show_signing_line_check" id="show_signing_line_check" checked="checked">
							                <label for="show_signing_line_check">Show signing line</label>											
										</p>
										<p>
										    <label for="signing_line_left_text">Left: </label>
								            <input type="text" name="signing_line_left_text" id="signing_line_left_text" value="30">
											<br>
											<label for="signing_line_right_text">Right: </label>
								            <input type="text" name="signing_line_right_text" id="signing_line_right_text" value="30">
										</p>
										<p>
										    <label for="signing_line_width_text">Width: </label>
								            <input type="text" name="signing_line_width_text" id="signing_line_width_text" value="2">
											<br>
											<label for="signing_line_offset_y_text">Offset y: </label>
								            <input type="text" name="signing_line_offset_y_text" id="signing_line_offset_y_text" value="5">
										</p>
										<p>
										    <label for="signing_line_color_box">Text color</label>			
			                                <input type="color" name="signing_line_color_box" id="signing_line_color_box" value="#D3D3D3">							
										</p>
									</div>
								</fieldset>
                            </p>							
							<fieldset>
							    <legend>Buttons</legend>
								<p>
								    <label for="button_font_type">Font type:</label>
									<input type="text" name="button_font_type" id="button_font_type" value="Arial">
								</p>
								<div>
									<button onClick="addButton()">Add Button</button>
								</div>
								<p>
								    <div id="button_list_div">
									    <fieldset id="clear_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*clear">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="clear">
                                            </p>											
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('clear_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
										<fieldset id="cancel_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*cancel">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="cancel">
                                            </p>
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('cancel_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
										<fieldset id="accept_btn_div_default">
										    <p>
									            <label for="button_text">Button Text:</label>
									            <input type="text" name="button_text" value="*ok">	
										    </p>
											<p>
										        <label for="button_action">Action:</label>
										        <input type="text" name="button_action" value="accept">
                                            </p>											
											<p>
											    <label for="button_text_color">Text color:</label>
												<input type="color" name="button_text_color" value="#000000">
											</p>
											<p>
											    <label for="button_background_color">Background color:</label>
												<input type="color" name="button_background_color" value="#e7e7e7">
											</p>
											<p>
											    <label for="button_border_width">Border width:</label>
												<input type="text" name="button_border_width" value="1">
											</p>
											<p>
											    <label for="button_border_color">Border color:</label>
												<input type="color" name="button_border_color" value="#cccccc">
											</p>
											<p>
                                                <button onClick="removeButton('accept_btn_div_default')">Remove</button>									
											</p>	
								        </fieldset>
								    </div>
								</p>
							</fieldset>							
		                </fieldset>
						<fieldset style="width:400px;padding:5px;margin:5px">
						    <legend>Render</legend>
							<p>
							    In order to determinate the size of the image, if none of the width and height are defined it will render
								the signature with its real size. If only one value, width or height is defined, it will render maintaining the proportion
								rescpect with the entered value. If defined both values it will render with the defined dimensions.								
							</p>
							<p>
							<label for="render_width">Width:</label>
							<input type="input" name="render_width" id="render_width" value="400"> px
							</p>
							<p>
							<label for="render_height">Height:</label>
							<input type="input" name="render_height" id="render_height" value="300"> px
							</p>
							<p>
							    If render relative both dimensions Width and Height, should be equals. In case the two of them are provided the Height will be ignored.
								<br>
								<input type="checkbox" name="is_relative" id="is_relative">
							    <label for="is_relative">Set as relative</label>								    								
							</p>
						</fieldset>
					</div>
				</div>
		    </div>		
        </div>		
		<div id="footer_container">
            <div id="footer">
	            <a style="color:white" href="https://www.wacom.com/en-us/privacy">Wacom privacy policy</a> - 
		        <a style="color:white" href="https://www.wacom.com/en-us/cookie-notice">Wacom cookie policy</a> - Copyright © 2021 Wacom Company, Limited. All Rights Reserved. All other trademarks are the property of their respective owners and are used with their permission. Modifications and errors excepted.
	        </div>
        </div>        	
	</body>
	<script>
        // Get the element with id="defaultOpen" and click on it
        document.getElementById("capture_signature_tab").click();
    </script>
</html>